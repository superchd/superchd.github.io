---
layout: single
title: "FFT"
categories : signal
tag: [signal, fft]
toc: true
author_profile : false
use_math: true
sidebar:
     nav: "docs"

---

### Fourier series

* Periodic signal을 periodic signal의 합으로 나타내자.

### Fourier transform 

* Fourier series의 확장버전(비주기함수에 대한 fourier series라 볼 수 있다. )

* 주기를 무한대로 볼때, aperiodic signal을 aperiodic signal의 합으로 나타내자.

* Fourier transform을 통해, 변환 전값과 변환 후 값이 1대1대응을 이룬다.  

*  **아이디어**

  > 주기신호의 주기를 무한대로 보내서 비주기신호로 보겠다 라는 아이디어 
  >
  > 퓨리에 계수를 보니 주기가 늘어날수록 작아진다 당연히 T0를 무한대로 보내면 a_K는 0으로 수렴한다.  
  >
  > 하지만, T0a_k 그래프를 보면, 주기가 무한대로 발산해도 값이 실수값을 가진다. 

$$
a_k = {\frac{1}{T_0} \int_\frac{-T_0}{2}^\frac{T_0}{2} \! x_{T_0} \mathrm{e}^{-jk\omega t}\, dt }
$$

![스크린샷 2022-08-16 오전 11.38.12](../images/2022-08-06-fft/스크린샷 2022-08-16 오전 11.38.12.png)





<img src="../images/2022-08-06-fft/스크린샷 2022-08-16 오전 1.23.07.png" alt="스크린샷 2022-08-16 오전 1.23.07" style="zoom: 67%;" />![스크린샷 2022-08-16 오전 1.31.23](../images/2022-08-06-fft/스크린샷 2022-08-16 오전 11.39.45.png)



### Derivation of FT and IFT

* 비주기 신호에 관한 퓨리에 시리즈가 어떻게 될지 관찰해보자

$$
a_kT_0 = \lim_{T_0 \to \infty}{\int_\frac{-T_0}{2}^\frac{T_0}{2} \! x_{T_0}(t) \mathrm{e}^{-jk\omega_0 t}\, dt }
$$



* 이때, 극한을 취하면 다음과 같이 나타날 수 있다.

$$
{x_{T_0}(t) = x(t)} \\
{a_kT_0 = X(KW_0)} \\
KW_0 = w(=실수) \\
X(w) = \int_{-\infty}^{\infty} x(t)\mathrm{e}^{-j\omega t}\ dt
$$

* x(t)를 가지고 X(w)를 만든다. 일대일 대응을 이루기 떄문에 역방향으로도 표현가능하다.

* 각각 내적을 해보면서 느린애도 내적해보고 빠른애도 내적해보고, 어떤 주파수와 닮았는지 확인하는 과정이다.



### contribution(a_k)

 

<img src="../images/2022-08-06-fft/스크린샷 2022-08-16 오전 1.53.20.png" alt="스크린샷 2022-08-16 오전 1.53.20" style="zoom:50%;" />

다음과 같은 주파수의 100hz의 contribution은 얼마인가? 

바로 넓이 -> 밀도를 이야기하는것 , 마치 확률밀도함수 같은것 !! 



### //FT of delta function//



### Discrete Time Fourier Series

$$
x_{T_0}(t) = \displaystyle\sum_{k=-\infin}^{\infin}{a_k e^{jk\omega_0t}} \\
x_N[n] = \displaystyle\sum_{k=-\infin}^{\infin}{a_k e^{jk\frac{2\pi}{N}n}} \\
$$

* 여기서 중요한것은, k = 1일때 , k = n + 1일때, 기저벡터가 일치한다는 것이다.
* basis가 반복이 되니까, 결국 실질적으로 구성되는 basis는 n개뿐이다. n주기를 가지고 반복된다

* 이번에는 ak를 구하기 위해서 각 기저벡터를 내적해보자.

$$
\displaystyle\sum_{n=<N>}{X_N[n]e^{jr\frac{2\pi}{N}n}} = \displaystyle\sum_{n=<N>}\displaystyle\sum_{k=<N>}{a_k e^{jk\frac{2\pi}{N}n} e^{-jr\frac{2\pi}{N}n}} \\
$$

* k = r일때만 값이 0 이 아니다. 따라서,

$$
a_k = \frac{1}{N}{\sum_{n = <N>}x_n[n]{e}^{-jk\frac{2\pi}{N}n}\ }
$$





### Discrete Time Fourier Transform

* 그전과 똑같이 비주기 함수는 주기함수의 주기를 무한대로 발산시켰을때의 함수라고 보자.
* 주기를 늘리기전과 후의 결과값 비교!

<img src="../images/2022-08-06-fft/스크린샷 2022-08-16 오전 11.52.10.png" alt="스크린샷 2022-08-16 오전 11.52.10"  />

<img src="../images/2022-08-06-fft/스크린샷 2022-08-16 오전 2.49.52.png" alt="스크린샷 2022-08-16 오전 2.49.52" style="zoom:67%;" />




$$
a_kN ={\sum_{n = <N>}x_n[n]{e}^{-jk\frac{2\pi}{N}n}\ } \\
n -> \infty\\
x_n[n] = x[n]\\
a_kN = X(K\ohm_0)\\
k\ohm_0 -> 0부터 2\pi사이의 실수값 = \ohm \\
X(\ohm) = {\sum_{n = <N>}x[n]{e}^{-j\ohm n}\ }
$$


### Discrete Fourier Transform

* 실제로 컴퓨터에서 써먹을 수 있다. (디지털 도메인에서 활용가능)
* discrete transform 해서 discrete 한값이 output으로 나온다. (CTFS, DTFS든 output이 연속적인 값이였다.)
* 정의 : 0 ~ N-1까지 값을 가지는 x[n]을 dtft한 다음 2pi/n간격으로 값을 뽑는다.(sampling과는 다르다.)


$$
X_K=X(K\frac{2\pi}{N}) = {\sum_{n = <N>}x[n]{e}^{-j\ohm n}\ }\\
$$

### DFT matrix

$$
X_K= {\sum_{n = 0}^{N-1}x[n]{e}^{-jk\frac{2\pi}{N}n}\ }
$$



* k를 바꿔가면서 내적을 한다 -> 다음과 같이 행렬로 나타낸다

* 예시(3개의 데이터를 넣고, 3개의 값을 받는다.)

$$
\begin{bmatrix}
    X_0 \\
    X_1 \\        
    X_2
\end{bmatrix} = 
\begin{bmatrix}
    e^{-j0\frac{2\pi}{N}0}&e^{-j0\frac{2\pi}{N}1}&e^{-j0\frac{2\pi}{N}2} \\
    e^{-j1\frac{2\pi}{N}0}&e^{-j1\frac{2\pi}{N}1}&e^{-j1\frac{2\pi}{N}2} \\
    e^{-j2\frac{2\pi}{N}0}&e^{-j2\frac{2\pi}{N}1}&e^{-j2\frac{2\pi}{N}2}
\end{bmatrix} 
\begin{bmatrix}
    x[0] \\
    x[1] \\        
    x[2]
\end{bmatrix}
$$

* <img src="../images/2022-08-06-fft/스크린샷 2022-08-16 오후 12.08.32.png" alt="스크린샷 2022-08-16 오후 12.08.32" style="zoom: 67%;" />
* ![스크린샷 2022-08-16 오후 12.10.48](../../../Library/Application Support/typora-user-images/스크린샷 2022-08-16 오후 12.10.48.png)![스크린샷 2022-08-16 오후 12.09.21]()
* ![스크린샷 2022-08-16 오후 12.11.14](../images/2022-08-06-fft/스크린샷 2022-08-16 오후 12.11.14.png)

* Orthogonal -> orthonormal한 벡터를 column으로 가지고 있는 행렬
* unitary matrix로 만들면 장점이 있다. -> IDFT를 구하기 매우 쉽다. (복소수의conjugate 성질에 의해)



## 제한시간이 1초일 경우, N의범위에 따른 시간복잡도 선택

- N 의 범위가 500 인 경우
  - 시간 복잡도가 O(N^3) 이하인 알고리즘을 설계
- N 의 범위가 2,000 인 경우
  - 시간 복잡도가 O(N^2) 이하인 알고리즘을 설계
- N 의 범위가 100,000 인 경우
  - 시간 복잡도가 O(NlogN) 이하인 알고리즘을 설계
- N 의 범위가 10,000,000 인 경우
  - 시간 복잡도가 O(N) 이하인 알고리즘을 설계
- N 의 범위가 10,000,000,000 인 경우
  - 시간 복잡도가 O(logN) 이하인 알고리즘을 설계![스크린샷 2022-08-16 오후 12.50.29](../images/2022-08-06-fft/스크린샷 2022-08-16 오후 12.50.29.png)





## FFT

다항식 곱과 비슷하다.~



다항식곱은 계수만 작업해서 필요하다~~



시간복잡도 -> $d^2



일대일 대응이다 그림과 ~~



행렬로 쓰면 -> 역변환이 가능하다는 점이 장점 



coefficiendt representation 

value representation 



 magical ?? 

이렇게 시간복잡도를 줄이는 구나~~





